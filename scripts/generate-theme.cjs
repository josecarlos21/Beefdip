const fs = require('fs');
const path = require('path');

const TOKENS_DIR = path.join(__dirname, '../tokens');
const OUTPUT_FILE = path.join(__dirname, '../public/theme.js');

// 1. Read all token files and merge them
function loadTokens() {
    const levels = ['0-atomic', '1-semantic', '2-component', '3-pattern', '4-contextual'];
    let allTokens = {};

    levels.forEach(level => {
        const levelDir = path.join(TOKENS_DIR, level);
        if (fs.existsSync(levelDir)) {
            const files = fs.readdirSync(levelDir).filter(f => f.endsWith('.json'));
            files.forEach(file => {
                const content = JSON.parse(fs.readFileSync(path.join(levelDir, file), 'utf8'));
                allTokens = deepMerge(allTokens, content);
            });
        }
    });

    return allTokens;
}

function deepMerge(target, source) {
    for (const key in source) {
        if (source[key] instanceof Object && key in target && !source[key].$value) {
            Object.assign(source[key], deepMerge(target[key], source[key]));
        } else {
            target[key] = source[key];
        }
    }
    return target;
}

// 2. Resolve references
function resolveReferences(tokens) {
    const regex = /{([^}]+)}/g;

    function getValue(pathStr, root) {
        const keys = pathStr.split('.');
        let current = root;
        for (const key of keys) {
            if (current && current[key]) {
                current = current[key];
            } else {
                return null;
            }
        }
        return current ? current.$value : null;
    }

    function resolve(value, root) {
        if (typeof value !== 'string') return value;
        if (!value.includes('{')) return value;

        return value.replace(regex, (match, pathStr) => {
            const resolvedVal = getValue(pathStr, root);
            if (resolvedVal) {
                // Recursively resolve if the resolved value itself has references
                return resolve(resolvedVal, root);
            }
            console.warn(`Could not resolve reference: ${pathStr}`);
            return match;
        });
    }

    function traverse(node, root) {
        if (typeof node === 'object' && node !== null) {
            if (node.hasOwnProperty('$value')) {
                node.$value = resolve(node.$value, root);
            } else {
                for (const key in node) {
                    traverse(node[key], root);
                }
            }
        }
    }

    traverse(tokens, tokens);
    return tokens;
}

// 3. Transform to Tailwind Config structure (removing $value)
function stripMetadata(node) {
    if (typeof node === 'object' && node !== null) {
        if (node.hasOwnProperty('$value')) {
            return node.$value;
        } else {
            const result = {};
            for (const key in node) {
                result[key] = stripMetadata(node[key]);
            }
            return result;
        }
    }
    return node;
}

function mapToTailwind(tokens) {
    const cleanTokens = stripMetadata(tokens);

    const theme = {
        extend: {
            colors: cleanTokens.color || {},
            fontFamily: cleanTokens.font || {},
            borderRadius: cleanTokens.radius || {},
            backdropBlur: cleanTokens.effect ? cleanTokens.effect.blur : {},
            blur: cleanTokens.effect ? cleanTokens.effect.blur : {}, // Map to both for utility
            animation: cleanTokens.animation || {},
            keyframes: cleanTokens.keyframes || {}
        }
    };

    // Specific cleanup for colors: remove 'base' if it shouldn't be top level,
    // but in Tailwind extending colors includes everything.

    return theme;
}

// Main execution
try {
    console.log('Generating theme...');
    const tokens = loadTokens();
    const resolvedTokens = resolveReferences(tokens);
    const themeConfig = mapToTailwind(resolvedTokens);

    const fileContent = `
// Generated by scripts/generate-theme.cjs
// Do not edit directly.

window.tailwind = window.tailwind || {};
window.tailwind.config = {
    darkMode: 'class',
    theme: ${JSON.stringify(themeConfig, null, 4)}
};
`;

    if (!fs.existsSync(path.dirname(OUTPUT_FILE))) {
        fs.mkdirSync(path.dirname(OUTPUT_FILE));
    }

    fs.writeFileSync(OUTPUT_FILE, fileContent);
    console.log(`Theme generated at ${OUTPUT_FILE}`);

} catch (err) {
    console.error('Error generating theme:', err);
    process.exit(1);
}
