const fs = require('fs');
const path = require('path');

// Helper to recursively read directory
function getFiles(dir) {
  const dirents = fs.readdirSync(dir, { withFileTypes: true });
  const files = dirents.map((dirent) => {
    const res = path.resolve(dir, dirent.name);
    return dirent.isDirectory() ? getFiles(res) : res;
  });
  return Array.prototype.concat(...files);
}

// Deep merge helper
function deepMerge(target, source) {
  for (const key in source) {
    if (source[key] instanceof Object && key in target) {
      Object.assign(source[key], deepMerge(target[key], source[key]));
    }
  }
  Object.assign(target || {}, source);
  return target;
}

// Resolve references like {color.primary}
function resolveReferences(obj, root) {
  const regex = /\{([^}]+)\}/g;

  function getValue(path, obj) {
    return path.split('.').reduce((acc, part) => acc && acc[part], obj);
  }

  function resolve(value) {
    if (typeof value === 'string') {
      return value.replace(regex, (match, path) => {
        const refVal = getValue(path, root);
        if (refVal && refVal.$value) {
           return resolve(refVal.$value);
        }
        return refVal || match;
      });
    }
    return value;
  }

  function traverse(node) {
    if (node && typeof node === 'object') {
      if (node.$value) {
        node.$value = resolve(node.$value);
      } else {
        for (const key in node) {
          traverse(node[key]);
        }
      }
    }
  }

  traverse(obj);
  return obj;
}

// Convert to Tailwind Theme Structure
function toTailwind(tokens) {
  const theme = {
    extend: {}
  };

  // Helper to extract values
  function extractValues(obj) {
    const res = {};
    for (const key in obj) {
        if (key.startsWith('$')) continue;
        const val = obj[key];
        if (val.$value !== undefined) {
             // If it's a keyframe definition (object value)
            if (typeof val.$value === 'object') {
                res[key] = val.$value;
            } else {
                res[key] = val.$value;
            }
        } else if (typeof val === 'object') {
            const nested = extractValues(val);
            if (Object.keys(nested).length > 0) {
                 res[key] = nested;
            }
        }
    }
    return res;
  }

  // Generic mapping strategy
  // We map top level token categories to Tailwind theme keys
  // Some need special handling (like colors being flattened or structured)

  if (tokens.color) theme.extend.colors = extractValues(tokens.color);
  if (tokens.font && tokens.font.family) theme.fontFamily = extractValues(tokens.font.family); // Top level usually
  if (tokens.font && tokens.font.weight) theme.extend.fontWeight = extractValues(tokens.font.weight);
  if (tokens.spacing) theme.extend.spacing = extractValues(tokens.spacing);
  if (tokens.radius) theme.extend.borderRadius = extractValues(tokens.radius);
  if (tokens.animation) theme.extend.animation = extractValues(tokens.animation);
  if (tokens.keyframes) theme.extend.keyframes = extractValues(tokens.keyframes);

  return theme;
}

// Main execution
const tokensDir = path.resolve(__dirname, '../tokens');
const files = getFiles(tokensDir).filter(f => f.endsWith('.json'));

let allTokens = {};
files.sort().forEach(file => {
  const content = JSON.parse(fs.readFileSync(file, 'utf8'));
  deepMerge(allTokens, content);
});

// Resolve references
resolveReferences(allTokens, allTokens);

// Transform to Tailwind Config Object
const tailwindTheme = toTailwind(allTokens);

// Output JS file
const outputContent = `
// Generated by scripts/generate-theme.cjs
window.tailwindConfig = {
  darkMode: 'class',
  theme: {
    extend: ${JSON.stringify(tailwindTheme.extend, null, 2)},
    fontFamily: ${JSON.stringify(tailwindTheme.fontFamily || {}, null, 2)}
  }
};
`;

fs.writeFileSync(path.resolve(__dirname, '../public/theme.js'), outputContent);
console.log('Theme generated at public/theme.js');
